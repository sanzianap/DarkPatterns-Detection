As of now, Chrome extensions do not support specifying the module type directly for content scripts in the `manifest.json`. However, you can work around this limitation by using a bundler like Webpack or Rollup to bundle your ES6 modules into a single script file that can be included as a content script.

Here's how you can do it using Webpack:

### Step 1: Set Up Webpack

1. **Install Webpack and Webpack CLI**:

   ```bash
   npm install webpack webpack-cli --save-dev
   ```

2. **Create a Webpack Configuration File** (`webpack.config.js`):

   ```javascript
   const path = require('path');

   module.exports = {
     entry: './src/main.js',
     output: {
       filename: 'bundle.js',
       path: path.resolve(__dirname, 'dist'),
     },
     module: {
       rules: [
         {
           test: /\.js$/,
           exclude: /node_modules/,
           use: {
             loader: 'babel-loader',
             options: {
               presets: ['@babel/preset-env'],
             },
           },
         },
       ],
     },
     resolve: {
       extensions: ['.js'],
     },
   };
   ```

3. **Install Babel and Babel Loader**:

   ```bash
   npm install @babel/core babel-loader @babel/preset-env --save-dev
   ```

4. **Create a Babel Configuration File** (`.babelrc`):

   ```json
   {
     "presets": ["@babel/preset-env"]
   }
   ```

### Step 2: Organize Your Source Files

1. **Create a `src` Directory**:
   - Place your source files (`constants.js` and `main.js`) in the `src` directory.

   ```javascript
   // src/constants.js
   export const COOKIE_KEYWORD = 'cookie';
   export const ANOTHER_CONSTANT = 'anotherValue';
   ```

   ```javascript
   // src/main.js
   import { COOKIE_KEYWORD, ANOTHER_CONSTANT } from './constants.js';

   document.querySelectorAll(`div[id*="${COOKIE_KEYWORD}"]`).forEach(div => {
     let parent = div.parentElement;
     let hasCookieAncestor = false;
     
     // Check all ancestors
     while (parent) {
       if (parent.id.includes(COOKIE_KEYWORD)) {
         hasCookieAncestor = true;
         break;
       }
       parent = parent.parentElement;
     }
     
     // If no ancestor has 'cookie' in the id, apply style
     if (!hasCookieAncestor) {
       div.style.backgroundColor = 'yellow'; // Just for demonstration
     }
   });

   console.log(ANOTHER_CONSTANT); // Just to demonstrate using another constant
   ```

### Step 3: Build the Bundle

1. **Run Webpack to Bundle Your Files**:

   ```bash
   npx webpack --mode production
   ```

2. **Webpack will output a bundled file (`bundle.js`) in the `dist` directory**.

### Step 4: Update `manifest.json`

1. **Modify your `manifest.json` to use the bundled file**:

   ```json
   {
     "manifest_version": 3,
     "name": "Your Extension Name",
     "version": "1.0",
     "description": "Your extension description.",
     "background": {
       "service_worker": "background.js",
       "type": "module"
     },
     "content_scripts": [
       {
         "matches": ["<all_urls>"],
         "js": ["dist/bundle.js"]
       }
     ],
     "permissions": [
       "activeTab"
     ]
   }
   ```

### Explanation:

1. **Webpack Configuration**:
   - The Webpack config sets up the entry point (`src/main.js`), output file (`dist/bundle.js`), and uses Babel to transpile ES6 code.

2. **Babel Configuration**:
   - Babel presets transform ES6 code into browser-compatible JavaScript.

3. **Bundling**:
   - Run Webpack to bundle your ES6 modules into a single file (`bundle.js`).

4. **Manifest Configuration**:
   - Specify the bundled file in the `content_scripts` section of your `manifest.json`.

This approach allows you to use ES6 modules in your content scripts by bundling them into a single file that can be loaded by the Chrome extension.